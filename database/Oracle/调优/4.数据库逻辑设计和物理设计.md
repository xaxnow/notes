# 4.1 逻辑数据模型
## 4.1.1 标准化和第三范式
**第三范式**:"键,完整的键,除了键没有其他东西"
+ 实体(表)的所有数据完全依赖于主键
+ 不能有重复的属性(列)或属性组
+ 不存在仅依赖部分主键的数据
+ 不存在依赖于其他非主键的实体数据
## 4.1.2 数据类型选择
+ 固定长度与可变长度字符串
+ 整数和浮点数
+ LONG,LOB,与字符串相对
+ 各种日期类型变种
## 自然键和人造键
**自然键**:实体中具有唯一性的自然属性构成,可以由多列组成并包含任何数据类型
**人造键**:无任何含义,用于标识实体唯一记录,大多是连续的数字
## 4.1.4 数据仓库设计
&emsp;&emsp;星型模型和雪花模型
# 4.2 逻辑模型到物理模型的映射
## 4.2.1 将实体或类映射成表
**实体子类映射为表**:
+ 为父类和子类建立单独的表.父类包含子类共有字段
+ 仅建立父类表,子类属性为父类表列,这些属性可为null,且有一列标识属于哪个子类
+ 仅建立子类表,子类包含父类属性对应的列
## 4.2.2 选择表的类型
&emsp;&emsp;见第5章
## 4.2.3 数据类型和精度
+ 字符小于4000varchar2,大于4000LOB
+ SecureFiles比LOB性能更好
## 4.2.4 可选的属性和null值
&emsp;&emsp;属性列为null的值不能使用b*tree索引,所以如果可能可以提供一个不影响计算的默认值
## 4.2.5 列的顺序
# 4.3 反规范化
&emsp;&emsp;规范化是为了消除冗余和重复组,并确保关键属性的定义是正确的.而反规范化则是为了提高性能.
## 4.3.1 复制列值以避免表连接
## 4.3.2 概要表
&emsp;&emsp;生成汇总或聚集信息的查询.
+ 如果是实时的则可以使用触发器或物化视图
+ 实时是非必须的,定期更新概要表
## 4.3.3 垂直分区
&emsp;&emsp;垂直分区:经常访问的表保留在主表,较少访问的在第二张表.
# 4.4 星型模型
## 4.4.1 星型模型基础
## 4.4.2 雪花模型
## 4.4.3 维度层次结构
## 4.4.4 聚集和物化视图
## 4.4.5 物化视图最佳实践
注意事项:
+ 物化视图所包括的每一张表,都要创建物化视图日志
+ 使用create dimension标识各维度层次关系
+ 设置参数query_rewrite_enabled,启动查询重写
+ 刷新策略选择,on commit/demand
+ 参数query_rewrite_integrity.确定物化视图与底层表数据同步的情况下才能使用查询重写.enforced必须同步,trusted假定已经同步,stable_tolerate不同步也能够重写
# 4.5 物理存储方案
## 4.5.1 数据段存储手工管理和自动管理
## 4.5.2 并行插入和空闲列表
&emsp;&emsp;插入时要有足够的数据块链表
## 4.5.3 pctfree和pctused(user_tables查看)
**pctfree**:数据块预留多少空闲空间用作记录更新的行长度增加,低于pctfree时不能插入记录,设置太小可能造成行迁移
**pctused**:在做一些删除后,空闲空间达到多少时可以存储新的记录
## 4.5.4 压缩
## 4.5.5 大数据字段LOB存储
+ LOB不会与同一行记录的其他列存储在一起,可以使用子句决定是否存储在行中
+ 当LOB数据存储在表外的时候,以chunk为最小存储单位.
+ 可以将LOB存储在数据段不同的表空间
+ 可以显式的设置是否可以存储在告诉缓存
+ secureFile
# 4.6 分区
## 4.6.1 分区类别
+ 范围分区
+ 散列分区
+ 列表分区
+ 参考引用分区
+ 虚拟列分区
## 4.6.2 组合分区
&emsp;&emsp;主分区下可以子分区      
&emsp;&emsp;主要是在范围,散列,列表类型组合
