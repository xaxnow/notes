
### 与VM区别

VM是基于硬件的，从硬件层面虚拟化一个完整的操作系统，再在上面运行应用
容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟

### Docker 镜像
一个特殊的文件系统，包含容器运行的程序，库，配置等资源

分层存储:
利用 Union FS (opens new window) 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成


### Docker 容器

从镜像创建的实例。
镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。
容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。
按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 `数据卷（Volume）`、或者 `绑定宿主目录`，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。

### Docker Registry  
存储和分发容器镜像的地方。

里面有多个`仓库` repository, 每个仓库包含多个版本，通过tag标记多个版本


##  使用镜像

```bash
# 拉取镜像
docker pull
# 运行镜像
docker run
# 列出镜像
docker image ls

# 查看镜像、容器、数据卷所占用的空间
docker system df

```

镜像体积: 下载的是压缩后的。列出的是可能包含其他镜像展开后共享的一些层，所以体积可能更小
虚悬镜像 dangling image：没有仓库名和标签的镜像。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像

```bash
docker image ls -f dangling=true
```

中间层镜像:加速镜像构建、重复利用资源，Docker 会利用 中间层镜像,默认的 `docker image ls` 列表中只会显示顶层镜像.加参数`-a`可能看到中间层镜像。
也可能看到无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。

```bash
# 列出部分镜像
docker image ls ubuntu
docker image ls ubuntu:18.04
docker image ls -f since=mongo:3.2
docker image ls -f label=com.example.version=0.1
# 特定格式显示
docker image ls -q

# go模板语法显示
docker image ls --format "{{.ID}}: {{.Repository}}"
docker image ls --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"
```

## 删除本地镜像

```bash
# <镜像> 可以是 镜像短 ID、镜像长 ID、镜像名 <仓库名>:<标签> 或者 镜像摘要
$ docker image rm [选项] <镜像1> [<镜像2> ...]
# 短ID， Image Id 前几位字符

# 镜像摘要
docker image ls --digests


docker image rm $(docker image ls -q redis)
```

Untagged 和Deleted：由于镜像的依赖关系，delete可能并不是真正的删除，而是Untagged去取消对应到该镜像的标签

## 使用Commit理解镜像构成

Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。

会导致镜像臃肿

## 操作容器

```bash
# -i -t -d
docker run 
docker container stop/restart/start

# 进入后台 -i -t
docker exec
# attach中输入exit会导致容器终止
docker attach

```


## 使用DockerFile定制镜像

[https://yeasy.gitbook.io/docker_practice/image/dockerfile](https://yeasy.gitbook.io/docker_practice/image/dockerfile)

特殊镜像`scratch`,虚拟空白的镜像。不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 (opens new window) 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。
```bash
# From指定基础镜像
FROM nginx

# RUN 执行命令 Dockerfile 中每一个指令都会建立一层
RUN apt-get update
# 两种格式
# shell 格式：RUN <命令>，就像直接在命令行中输入的命令一样
# exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。
# 使用 && 实现执行一个命令，避免创建多层

# COPY 复制文件
COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]

# ADD 更高级的文件复制
# 可以下载URL文件，压缩包并解压到目标路径
ADD --chown=<user>:<group> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /

# CMD 容器启动命令
# 与RUN类似有exec和shell两种格式
# Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的
# Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。
# 区别 CMD service nginx start，会被理解为 CMD [ "sh", "-c", "service nginx start"]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。
# 正确写法如下
CMD ["nginx", "-g", "daemon off;"]

# ENTRYPOINT入口点
# 格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式
# 1. 替代CMD让镜像能够加一些参数。变得像命令一样
# 2. 执行准备工作。比如一些数据库在启动前设置些用户组，用户等
ENTRYPOINT [ "curl", "-s", "http://myip.ipip.net" ]

# ENV 设置环境变量
ENV <key1>=<value1> <key2>=<value2>...
```