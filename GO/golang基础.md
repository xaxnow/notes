# 变量相关
## 变量使用注意
+ 初始化
+ 方法外只能使用关键字开头
+ 定义了必须被使用
+ 如果在方法内使用`var`开头声明变量,那么只能用`=`赋值,而不能使用`:=`赋值
> 如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。
```go
var a string
//这里就会出现 no new variables on left side of :=错误
a:="f"
```
+ 变量可以在一行同时赋值
```go
var a,b,c =1,2,"ff"
```
## 字符串
go中使用两个反斜杠保证字符被原样输出
```go
//\n将会被原样输出
fmt.Println(`this is a test \n`)
```
## 数组
+ 属于值类型,切片属于引用类型
+ 数组值是可变的
```go
var a  [6]int
a[5]=4
a=[...]int{2,5:5}
fmt.Println(a)
```
+ 数组中元素类型是一样的
+ 长度是固定的(即声明时必须指出其长度,编译时需要知道其长度分配内存)
+ 最大2GB     
### 声明
```go
//var identifier [length]type
var a [5]int
//赋值
a[0]=1
a[1]=2
//如果不是根据下标来赋值的话,必须按以下方式赋值(即数组常量)
a=[5]int{1,2,3}
```
### 数组常量
这是在数组值已经提前知道的情况下使用这种方式,即不用通过`[idx]=value`的方式来对每个元素赋值
```go
var a [5]int=[5]int{1,2,3}
//此方式后两个元素初始值都为0
var a = [5]int{1,2,3}
//此方式类似于切片的方式,长度为3
var a= [...]int{1,2,3}
//此方式类似于切片的方式,也可以包含key=value形式.长度为7
var a= [...]int{1,2,6:3}
//key=value形式
var a=[10]int{1:2,5:30}
```
### 多维数组
### 避免消耗大量内存
+ 使用数组指针
+ 使用数组切片(推荐)

## 切片

切片是对`数组`一段连续片段的引用(`该数组`称为相关数组,通常是匿名的),  
即在创建切片时会创建一个匿名的相关数组, 而切片就是使用相关数组指针,长度,容量构成和组织切片的
此外切片提供了`len()`和`cap()`,用来表示其长度和容量,且0<=len(s)<=cap(s)
+ 引用类型
+ 是一个可变长度的数组(可在运行时修改长度,最小为0,最大为相关数组的长度)
+ 默认未初始化前的值是nil
```go
//声明
var identifier []type 

//初始化,使用类似数组的方式初始话
//这样创建了一个长度为3的数组且创建了一个相关的切片
var a = []int{1,2,3}

a := make([]int,0,)
```
## make和new

## map
## function
## struct
## method
## interface
## reflection
## 值类型和引用类型
+ 值类型可以通过`new`创建
+ 值类型拷贝不改变元数据,而引用类型会,所以修改时要通过引用的方式
```


```