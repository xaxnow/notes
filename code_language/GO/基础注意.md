# 基础注意

## 值类型和引用类型

> 值类型:int,float,bool,string,array,struct.这些类型变量直接指向内存中的值.而引用类型变量存储的是该变量的值所在的内存地址.内存地址也被称为指针.所以在传递参数时使用指针会大幅提高性能,若使用变量名则使用的是值的拷贝

## 类型别名

```go
type newInt int
//newInt就是int的别名
var a newInt
```

## 在go中严格区分''和""

## 在局域变量中使用 :=

## 声明的变量/方法需要被使用,否则会报错

## 指针类型

>程序在内存中存储它的值，每个内存块（或字）有一个地址，通常用十六进制数表示，如：0x6b0820 或 0xf84001d7f0。
Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址
var intP *int
然后使用 intP = &i1 是合法的，此时 intP 指向 i1。
（指针的格式化标识符为 %p）
intP 存储了 i1 的内存地址；它指向了 i1 的位置，它引用了变量 i1。
一个指针变量可以指向任何一个值的内存地址 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；你可以在指针类型前面加上*号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器。使用一个指针引用一个值被称为间接引用

## if-else

```go
//可以在if语句前进行变量的赋值然后再进行判断
if a,b:=1,2; a<b{
    fmt.Print("a<b")
}

```

## 数组与其他变量初始化不同

```go
Var arr1 = [5]int{…}而不是var arr1 [5]int={…}
```

## 数组是值类型,是地址的副本.而切片是引用类型.所以在使用时参数使用切片效率更高

## 切片定义

- 定义了数组时使用

```go
Var arr2 = []int{…}
Slice = arr2[s:e]
```

- 未定义数组时使用

```go
var slice1 []type = make([]type, len)
slice1 := make([]type, len, cap)
make([]int, 50, 100)
new([100]int)[0:50]
```

### new和make定义的切片区别

- new(T) 为每个新的类型T分配一片内存，初始化为 0 并且返回类型为*T的内存地址：这种方法 返回一个指向类型为 T，值为 0 的地址的指针，它适用于值类型如数组和结构体（参见第 10 章）；它相当于 &T{}。
- make(T) 返回一个类型为 T 的初始值，它只适用于3种内建的引用类型：切片、map 和 channel（参见第 8 章，第 13 章）。换言之，new 函数分配内存，make 函数初始化；

